#!/bin/bash
shopt -s checkwinsize
$BASH -c : # trigger ^
declare -i LINE_STATUS=$LINES
declare -i LINE_COMMAND=$LINES-1
declare -i WINDOW_LINES=$LINES-2
declare -i LINE_OFFSET=0
declare -i COLUMN_OFFSET=0
declare -i COLUMN=1
declare -i LINE=1
declare -i LINE_CURSOR=1
declare -i COLUMN_CURSOR=1
declare -a BUFCSR=()
declare -i BUFIDX=0
declare -a BUFFER=('')
declare -n BUFCUR=BUFFER[0]
declare -x BUFCOM=''
declare LAST_KEY=''
declare MODE='NORMAL'
declare FILENAME="$1"
declare DIRTY=''
declare -ga BUFMATCH=('')
declare -gi IDXMATCH=0
declare -g BUFPATTERN=""

function process_input {
  read -rsN1 LAST_KEY
  if [[ $MODE = 'NORMAL' ]];then
    case $LAST_KEY in
      'k') up 1;;
      'K') up ${#BUFFER[@]};;
      'j') down 1;;
      'J') down ${#BUFFER[@]};;
      'h') left 1;;
      'H') left ${#BUFCUR};;
      'l') right 1;;
      'L') right ${#BUFCUR};;
      'i') MODE="INSERT";echo -ne '\e[6 q\e[?2c';;
      ':') command_enter;;
    esac
  elif [[ $MODE = 'INSERT' ]];then
    case "$LAST_KEY" in
      $'\e') MODE='NORMAL';echo -ne '\e[2 q\e[?6c';;
      $'\b') DIRTY=1;bs;;
      $'\177') DIRTY=1;bs;; # bs sends delete on my terminal
      $'\n') DIRTY=1;nl;;
      [[:print:][:space:]]) DIRTY=1;append "$LAST_KEY";;
    esac
  else
    case "$LAST_KEY" in
      $'\e') command_exit;;
      $'\n') command_eval;;
      $'\177') bs;; # bs is delete on my terminal
      $'\t') autocomplete "$BUFCOM";;
      [[:print:][:space:]]) BUFPATTERN='';append "$LAST_KEY";;
    esac
  fi
}
function cursor_save {
  BUFCSR+=("$LINE $COLUMN $LINE_CURSOR $COLUMN_CURSOR")
}
function cursor_restore {
  local -a last_pos=(${BUFCSR[-1]})
  LINE="${last_pos[0]}"
  COLUMN="${last_pos[1]}"
  LINE_CURSOR="${last_pos[2]}"
  COLUMN_CURSOR="${last_pos[3]}"
  echo -ne "\e[$LINE_CURSOR;${COLUMN_CURSOR}H"
  unset 'BUFCSR[-1]'
}
function up {
  (( lines_remaining=LINE-1 ))
  if (( lines_remaining > 0 ));then
    if (( lines_remaining > $1 ));then
      (( LINE-=$1 ))
      (( BUFIDX-=$1 ))
      (( LINE_CURSOR-=$1 ))
    else
      (( LINE=1 ))
      (( BUFIDX=0 ))
      (( LINE_CURSOR-=lines_remaining ))
    fi
    declare -gn BUFCUR=BUFFER[$BUFIDX]
    (( $COLUMN > ${#BUFCUR} )) && COLUMN=${#BUFCUR}+1
    (( COLUMN < COLUMNS )) && COLUMN_CURSOR=COLUMN
  fi
}
function down {
  (( lines_remaining=${#BUFFER[@]}-LINE ))
  if (( lines_remaining > 0 ));then
    if (( lines_remaining > $1 ));then
      (( LINE+=$1 ))
      (( BUFIDX+=$1 ))
      (( LINE_CURSOR+=$1 ))
    else
      (( LINE=${#BUFFER[@]} ))
      (( BUFIDX=${#BUFFER[@]}-1 ))
      (( LINE_CURSOR+=lines_remaining ))
    fi
    declare -gn BUFCUR=BUFFER[$BUFIDX]
    (( $COLUMN > ${#BUFCUR} )) && COLUMN=${#BUFCUR}+1
    (( COLUMN < COLUMNS )) && COLUMN_CURSOR=COLUMN
  fi
}
function left {
  (( columns_remaining=COLUMN-1 ))
  if (( columns_remaining > 0 ));then
    if (( columns_remaining > $1 ));then
      (( COLUMN-=$1 ))
      (( COLUMN_CURSOR-=$1 ))
    else
      (( COLUMN=1 ))
      (( COLUMN_CURSOR-=columns_remaining ))
    fi
  fi
}
function right {
  (( columns_remaining=${#BUFCUR}-COLUMN+1 ))
  if (( columns_remaining > 0 ));then
    if (( columns_remaining > $1 ));then
      (( COLUMN+=$1 ))
      (( COLUMN_CURSOR+=$1 ))
    else
      (( COLUMN=${#BUFCUR}+1 ))
      (( COLUMN_CURSOR+=columns_remaining ))
    fi
  fi
}
function nl {
  local yanked_text="${BUFCUR:$COLUMN-1}"
  declare -g ${!BUFCUR}="${BUFCUR:0:$COLUMN-1}"
  local -i i=${#BUFFER[@]} j=i+1
  while (( i > BUFIDX ));do
    BUFFER[$i]="${BUFFER[$i-1]}"
    (( i-- ))
    (( j-- ))
  done
  down 1
  declare -g ${!BUFCUR}="$yanked_text"
  left "${#BUFCUR}"
}
function bs {
  if (( COLUMN > 1 ));then
    left 1
    declare -g ${!BUFCUR}="${BUFCUR:0:$COLUMN-1}${BUFCUR:$COLUMN}"
  elif (( LINE > 1 )) && [ $MODE = 'INSERT' ];then
    local -i i=BUFIDX-1
    local len="${#BUFFER[$i]}"
    BUFFER[i]="${BUFFER[$i]}$BUFCUR"
    BUFFER=( "${BUFFER[@]::$BUFIDX}" "${BUFFER[@]:$(( BUFIDX+1 ))}" )
    up 1
    right len
  fi
}
function append {
  declare -g ${!BUFCUR}="${BUFCUR:0:$COLUMN-1}$1${BUFCUR:$COLUMN-1}"
  right 1
}
function replace {
  declare -g ${!BUFCUR}="$1"
  (( COLUMN=${#BUFCUR}+1 ))
  (( COLUMN_CURSOR${#BUFCUR}+1 ))
}
function command_enter {
  cursor_save
  LINE_CURSOR=$LINE_COMMAND
  COLUMN_CURSOR=1
  MODE='COMMAND'
  echo -ne '\e[6 q\e[?2c' # cursor bar (xterm et al) / underline VGA
  BUFCOM=''
  declare -gn BUFCUR=BUFCOM
}
function clear_line {
  echo -ne "\e[$LINE_CURSOR;1H\e[K"
}
function command_exit {
  cursor_restore
  MODE='NORMAL'
  echo -ne '\e[2 q\e[?8c' # cursor block
  declare -gn BUFCUR=BUFFER[$BUFIDX]
  BUFMATCH=('')
  IDXMATCH=0
  BUFPATTERN=""
}
function command_eval {
  clear_line
  eval "$BUFCOM"
  BUFCOM=""
  command_exit
}
function s {
  if [[ -z "$1" ]];then
    echo -n "No filename provided!"
  else
    echo -n '' > $1
    local -i i=0 len=${#BUFFER[@]}
    while (( i < len ));do
      echo "${BUFFER[$i]}" >> $1
      (( i++ ))
    done
    printf "\e[KWrote %d lines to %s" ${#BUFFER[@]} "$1"
    DIRTY=''
    [[ -z "$FILENAME" ]] && FILENAME="$1"
  fi
}
function o {
  if [[ -z $1 ]];then
    echo -ne "I need a filename to open"
  elif [[ ! -f $1 ]];then
    echo -ne "That file doesn't exist"
  elif [[ ! -r $1 ]];then
    echo -ne "I don't have permission to read that file"
  else
    save_dirty "Save before opening?"
    local line i=0
    declare -ga BUFFER=('')
    while IFS= read -rs line;do
      BUFFER[$i]="$line"
      (( i++ ))
    done < "$1"
    FILENAME="$1"
    LINE=1
    COLUMN=1
    DIRTY=''
  fi
}
function autocomplete {
  local words=( $1 )
  (( "${#words[@]}" < 2 )) && return # I only autocomplete args
  if [[ -z "$BUFPATTERN" ]];then
    BUFPATTERN="${words[-1]}"
    BUFMATCH=( $(compgen -f "$BUFPATTERN") )
    IDXMATCH=0
  fi
  if (( "${#BUFMATCH[@]}" > 0 ));then
    replace "${1% *} ${BUFMATCH[$IDXMATCH]}"
    (( IDXMATCH++ ))
    (( IDXMATCH == ${#BUFMATCH[@]} )) && IDXMATCH=0
  fi
}
function render {
  echo -ne '\e[?25l'
  if [ "$MODE" = 'COMMAND' ];then
    echo -ne "\e[$LINE_COMMAND;1H\e[K$BUFCOM"
  else
    if (( LINE_CURSOR < 1 ));then
      LINE_OFFSET=$LINE_OFFSET+$LINE_CURSOR-1
      LINE_CURSOR=1
    elif (( LINE_CURSOR > $WINDOW_LINES ));then
      LINE_OFFSET=$LINE_OFFSET+$LINE_CURSOR-$WINDOW_LINES
      LINE_CURSOR=$WINDOW_LINES
    fi
    if (( COLUMN_CURSOR < 1 ));then
      COLUMN_OFFSET=$COLUMN_OFFSET+$COLUMN_CURSOR-1
      COLUMN_CURSOR=1
    elif (( COLUMN_CURSOR > COLUMNS ));then
      COLUMN_OFFSET=$(( COLUMN_OFFSET+COLUMN_CURSOR-COLUMNS ))
      COLUMN_CURSOR=$COLUMNS
    fi
    cursor_save
    local -i i=$LINE_OFFSET j=1 h=$LINE_OFFSET+$WINDOW_LINES
    while (( i < h ));do
      echo -ne "\e[$j;1H\e[K"
      echo -n "${BUFFER[$i]:$COLUMN_OFFSET:$COLUMNS}"
      (( i++ ))
      (( j++ ))
    done
    local filename="$FILENAME"
    [[ -z "$FILENAME" ]] && filename="No filename"
    echo -ne "\e[$LINE_STATUS;1H\e[K$MODE\t$LINE,$COLUMN\t${#BUFFER[@]} LINES\t$filename\t$LINE_OFFSET\t$LINE_CURSOR,$COLUMN_CURSOR"
    cursor_restore
  fi
  echo -ne "\e[?25h" #\e[$LINE_CURSOR;${LINE_COLUMN}H"
}
function save_dirty {
  if [[ -n "$DIRTY" && -n "$FILENAME" ]];then
    local -u c
    read -N1 -p "$1 " c
    if [[ "$c" = 'Y' ]];then
      BUFCOM=''
      s "$FILENAME"
    fi
  fi
}
function q {
  save_dirty "Save before exiting?"
  echo -ne '\e[ q\e[?0c\ec' # reset cursor, clear screen, cursor
  exit
}
function _q {
  command_enter # jump to the command line
  clear_line    # render won't have run
  stty 'echo'   # re-enable because of read -s
  q             # now we're ready to shutdown
}
# main
trap _q INT
if [[ -f "$FILENAME" ]];then
  o "$FILENAME"
fi
while :; do render; process_input; done
