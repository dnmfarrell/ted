#!/bin/bash
shopt -s checkwinsize extglob
$BASH -c : # trigger checkwinsize to populate LINES && COLUMNS
declare -i LINE_STATUS=$LINES
declare -i LINE_COMMAND=$LINES-1
declare -i WINDOW_LINES=$LINES-2
declare -i LINE_OFFSET=0
declare -i COLUMN_OFFSET=0
declare -i COLUMN=1
declare -i LINE=1
declare -i LINE_CURSOR=1
declare -i COLUMN_CURSOR=1
declare -a BUFCSR=()
declare -i BUFIDX=0
declare -a BUFFER=('')
declare -n BUFCUR=BUFFER[0]
declare -x BUFCOM=''
declare LAST_KEY=''
declare MODE='NORMAL'
declare FILENAME="$1"
declare DIRTY=''
declare -ga BUFMATCH=('')
declare -gi IDXMATCH=0
declare -g BUFPATTERN=""
declare SEEN_WHITESPACE

function process_input {
  read -rsN1 LAST_KEY
  if [[ $MODE = 'NORMAL' ]];then
    case $LAST_KEY in
      '^') to_col 1;;
      '$') right ${#BUFCUR};;
      'k') up 1;;
      'K') up 25;;
      'j') down 1;;
      'J') down 25;;
      'h') left 1;;
      'H') word_back;;
      'l') right 1;;
      'L') word_fwd;;
      'a') insert_enter;right 1;;
      'A') insert_enter;right ${#BUFCUR};;
      'i') insert_enter;;
      'I') insert_enter;to_col 1;;
      'o') insert_enter;right ${#BUFCUR};nl;;
      'O') insert_enter;to_col 1;nl;up 1;;
      'S') insert_enter;DIRTY=1;replace;;
      ';') command_enter;;
    esac
  elif [[ $MODE = 'INSERT' ]];then
    case "$LAST_KEY" in
      $'\e') normal_enter;;
      $'\b') DIRTY=1;bs;;
      $'\177') DIRTY=1;bs;; # bs sends delete on my terminal
      $'\n') DIRTY=1;nl;;
      [[:print:][:space:]]) DIRTY=1;append "$LAST_KEY";;
    esac
  else
    case "$LAST_KEY" in
      $'\e') command_exit;;
      $'\n') command_eval;;
      $'\177') bs;; # bs is delete on my terminal
      $'\t') autocomplete "$BUFCOM";;
      [[:print:][:space:]]) BUFPATTERN='';append "$LAST_KEY";;
    esac
  fi
}
function cursor_save {
  BUFCSR+=("$LINE $COLUMN $LINE_CURSOR $COLUMN_CURSOR")
}
function cursor_restore {
  local -a last_pos=(${BUFCSR[-1]})
  LINE="${last_pos[0]}"
  COLUMN="${last_pos[1]}"
  LINE_CURSOR="${last_pos[2]}"
  COLUMN_CURSOR="${last_pos[3]}"
  echo -ne "\e[$LINE_CURSOR;${COLUMN_CURSOR}H"
  unset 'BUFCSR[-1]'
}
function up {
  (( lines_remaining=LINE-1 ))
  if (( lines_remaining > 0 ));then
    if (( lines_remaining > $1 ));then
      (( LINE-=$1 ))
      (( BUFIDX-=$1 ))
      (( LINE_CURSOR-=$1 ))
    else
      (( LINE=1 ))
      (( BUFIDX=0 ))
      (( LINE_CURSOR-=lines_remaining ))
    fi
    declare -gn BUFCUR=BUFFER[$BUFIDX]
    (( $COLUMN > ${#BUFCUR} )) && COLUMN=${#BUFCUR}+1
    (( COLUMN < COLUMNS )) && COLUMN_CURSOR=COLUMN
  fi
}
function down {
  (( lines_remaining=${#BUFFER[@]}-LINE ))
  if (( lines_remaining > 0 ));then
    if (( lines_remaining > $1 ));then
      (( LINE+=$1 ))
      (( BUFIDX+=$1 ))
      (( LINE_CURSOR+=$1 ))
    else
      (( LINE=${#BUFFER[@]} ))
      (( BUFIDX=${#BUFFER[@]}-1 ))
      (( LINE_CURSOR+=lines_remaining ))
    fi
    declare -gn BUFCUR=BUFFER[$BUFIDX]
    (( $COLUMN > ${#BUFCUR} )) && COLUMN=${#BUFCUR}+1
    (( COLUMN < COLUMNS )) && COLUMN_CURSOR=COLUMN
  fi
}
function left {
  (( columns_remaining=COLUMN-1 ))
  if (( columns_remaining > 0 ));then
    if (( columns_remaining > $1 ));then
      (( COLUMN-=$1 ))
      (( COLUMN_CURSOR-=$1 ))
    else
      (( COLUMN=1 ))
      (( COLUMN_CURSOR-=columns_remaining ))
    fi
  fi
}
function to_col {
  if (( $1 < COLUMN ));then
    left $(( $COLUMN-$1 ))
  elif (( $1 > COLUMN ));then
    right $(( $1-$COLUMN ))
  fi
}
function to_line {
  if (( $1 < LINE ));then
    up $(( $LINE-$1 ))
  elif (( $1 > LINE ));then
    down $(( $1-$LINE ))
  fi
}
function right {
  (( columns_remaining=${#BUFCUR}-COLUMN+1 ))
  if (( columns_remaining > 0 ));then
    if (( columns_remaining > $1 ));then
      (( COLUMN+=$1 ))
      (( COLUMN_CURSOR+=$1 ))
    else
      (( COLUMN=${#BUFCUR}+1 ))
      (( COLUMN_CURSOR+=columns_remaining ))
    fi
  fi
}
function nl {
  local yanked_text="${BUFCUR:$COLUMN-1}"
  declare -g ${!BUFCUR}="${BUFCUR:0:$COLUMN-1}"
  local -i i=${#BUFFER[@]} j=i+1
  while (( i > BUFIDX ));do
    BUFFER[$i]="${BUFFER[$i-1]}"
    (( i-- ))
    (( j-- ))
  done
  down 1
  declare -g ${!BUFCUR}="$yanked_text"
  to_col 1
}
function bs {
  if (( COLUMN > 1 ));then
    left 1
    declare -g ${!BUFCUR}="${BUFCUR:0:$COLUMN-1}${BUFCUR:$COLUMN}"
  elif (( LINE > 1 )) && [ $MODE = 'INSERT' ];then
    local -i i=BUFIDX-1
    local len="${#BUFFER[$i]}"
    BUFFER[i]="${BUFFER[$i]}$BUFCUR"
    BUFFER=( "${BUFFER[@]::$BUFIDX}" "${BUFFER[@]:$(( BUFIDX+1 ))}" )
    up 1
    right len
  fi
}
function word_back {
  if (( COLUMN > 1 )); then
    local words=(${BUFCUR:0:$COLUMN-1})
    if (( ${#words[@]} > 0 ));then
      local sentence="${BUFCUR%"${words[-1]}"*}"
      to_col $(( ${#sentence} + 1 ))
    else
      to_col 1
      word_back
    fi
  elif (( LINE > 1 ));then
    up 1
    right ${#BUFCUR}
    word_back
  fi
}
function word_fwd {
  if (( COLUMN > ${#BUFCUR} )) && (( LINE < LINES ));then
    down 1
    to_col 1
    SEEN_WHITESPACE=1
    word_fwd
  else
    local i=$(( COLUMN-1 ))
    local c="${BUFCUR:$i:1}"
    if [[ "$c" == [^[:space:]] ]];then
      if (( SEEN_WHITESPACE == 1 ));then
        SEEN_WHITESPACE=0
        return 0
      fi
    else
      SEEN_WHITESPACE=1
    fi
    right 1
    word_fwd
  fi
}
function append {
  declare -g ${!BUFCUR}="${BUFCUR:0:$COLUMN-1}$1${BUFCUR:$COLUMN-1}"
  right 1
}
function replace {
  declare -g ${!BUFCUR}="$1"
  (( COLUMN=${#BUFCUR}+1 ))
  (( COLUMN_CURSOR${#BUFCUR}+1 ))
}
function insert_enter {
  MODE='INSERT'
  echo -ne '\e[6 q\e[?2c' # cursor bar for xterm et al. underline for VGA
}
function normal_enter {
  MODE='NORMAL'
  echo -ne '\e[2 q\e[?8c' # cursor block for xterm et al + VGA
}
function command_enter {
  MODE='COMMAND'
  echo -ne '\e[6 q\e[?2c' # cursor bar for xterm et al. underline for VGA
  cursor_save
  LINE_CURSOR=$LINE_COMMAND
  COLUMN_CURSOR=1
  BUFCOM=''
  declare -gn BUFCUR=BUFCOM
}
function clear_line {
  echo -ne "\e[$LINE_CURSOR;1H\e[K"
}
function command_exit {
  cursor_restore
  declare -gn BUFCUR=BUFFER[$BUFIDX]
  BUFMATCH=('')
  IDXMATCH=0
  BUFPATTERN=""
  normal_enter
}
function s {
  if [[ -z "$1" ]];then
    echo -n "No filename provided!"
  else
    echo -n '' > $1
    local -i i=0 len=${#BUFFER[@]}
    while (( i < len ));do
      echo "${BUFFER[$i]}" >> $1
      (( i++ ))
    done
    printf "\e[KWrote %d lines to %s" ${#BUFFER[@]} "$1"
    DIRTY=''
    [[ -z "$FILENAME" ]] && FILENAME="$1"
  fi
}
function o {
  if [[ -z $1 ]];then
    echo -ne "I need a filename to open"
  elif [[ ! -f $1 ]];then
    echo -ne "That file doesn't exist"
  elif [[ ! -r $1 ]];then
    echo -ne "I don't have permission to read that file"
  else
    save_dirty "Save before opening?"
    local line i=0
    declare -ga BUFFER=('')
    while IFS= read -rs line;do
      BUFFER[$i]="$line"
      (( i++ ))
    done < "$1"
    FILENAME="$1"
    LINE=1
    COLUMN=1
    DIRTY=''
  fi
}
function autocomplete {
  local words=( $1 )
  (( "${#words[@]}" < 2 )) && return # I only autocomplete args
  if [[ -z "$BUFPATTERN" ]];then
    BUFPATTERN="${words[-1]}"
    BUFMATCH=( $(compgen -f "$BUFPATTERN") )
    IDXMATCH=0
  fi
  if (( "${#BUFMATCH[@]}" > 0 ));then
    replace "${1% *} ${BUFMATCH[$IDXMATCH]}"
    (( IDXMATCH++ ))
    (( IDXMATCH == ${#BUFMATCH[@]} )) && IDXMATCH=0
  fi
}
function render {
  echo -ne '\e[?25l'
  if [ "$MODE" = 'COMMAND' ];then
    echo -ne "\e[$LINE_COMMAND;1H\e[K$BUFCOM"
  else
    if (( LINE_CURSOR < 1 ));then
      LINE_OFFSET=$LINE_OFFSET+$LINE_CURSOR-1
      LINE_CURSOR=1
    elif (( LINE_CURSOR > $WINDOW_LINES ));then
      LINE_OFFSET=$LINE_OFFSET+$LINE_CURSOR-$WINDOW_LINES
      LINE_CURSOR=$WINDOW_LINES
    fi
    if (( COLUMN_CURSOR < 1 ));then
      COLUMN_OFFSET=$COLUMN_OFFSET+$COLUMN_CURSOR-1
      COLUMN_CURSOR=1
    elif (( COLUMN_CURSOR > COLUMNS ));then
      COLUMN_OFFSET=$(( COLUMN_OFFSET+COLUMN_CURSOR-COLUMNS ))
      COLUMN_CURSOR=$COLUMNS
    fi
    cursor_save
    local -i i=$LINE_OFFSET j=1 h=$LINE_OFFSET+$WINDOW_LINES
    while (( i < h ));do
      echo -ne "\e[$j;1H\e[K"
      echo -n "${BUFFER[$i]:$COLUMN_OFFSET:$COLUMNS}"
      (( i++ ))
      (( j++ ))
    done
    local filename="$FILENAME"
    [[ -z "$FILENAME" ]] && filename="No filename"
    echo -ne "\e[$LINE_STATUS;1H\e[K$MODE\t$LINE,$COLUMN\t${#BUFFER[@]} LINES\t$filename\t$LINE_OFFSET\t$LINE_CURSOR,$COLUMN_CURSOR"
    cursor_restore
  fi
  echo -ne "\e[?25h"
}
function save_dirty {
  if [[ -n "$DIRTY" && -n "$FILENAME" ]];then
    local -u c
    read -N1 -p "$1 " c
    if [[ "$c" = 'Y' ]];then
      BUFCOM=''
      s "$FILENAME"
    fi
  fi
}
function q {
  save_dirty "Save before exiting?"
  echo -ne '\e[ q\e[?0c\ec' # reset cursor, clear screen, cursor
  exit
}
function _q {
  command_enter # jump to the command line
  clear_line    # render won't have run
  stty 'echo'   # re-enable because of read -s
  q             # now we're ready to shutdown
}
function command_eval {
  clear_line
  if [[ "$BUFCOM" == +([[:digit:]]) ]]; then
    command_exit
    if (( BUFCOM > ${#BUFFER[@]} ));then
      to_line ${#BUFFER[@]}
    else
      to_line $BUFCOM
    fi
  else
    eval "$BUFCOM"
    command_exit
  fi
  BUFCOM=""
}
# main
trap _q INT
if [[ -f "$FILENAME" ]];then
  o "$FILENAME"
fi
while :; do render; process_input; done
