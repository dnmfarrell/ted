#!/bin/bash
shopt -s checkwinsize
bash -c : # trigger ^
declare TEDPATH=$(readlink -f "$0")
declare -i LINE_STATUS=$LINES
declare -i LINE_COMMAND=$LINES-1
declare -i WINDOW_LINES=$LINES-2
declare -i LINE_OFFSET=0
declare -i COLUMN_OFFSET=0
declare -i COLUMN=1
declare -i LINE=1
declare -i LINE_CURSOR=1
declare -i COLUMN_CURSOR=1
declare -a BUFCSR=()
declare -i BUFIDX=0
declare -a BUFFER=('')
declare -n BUFCUR=BUFFER[0]
declare -x BUFCOM=''
declare LAST_KEY=''
declare MODE='NORMAL'
declare FILENAME="$1"
declare DIRTY=''
declare -ga BUFMATCH=('')
declare -gi IDXMATCH=0
declare -g BUFPATTERN=""

function process_input {
  read -srN1 LAST_KEY
  if [[ $MODE = 'NORMAL' ]];then
    case $LAST_KEY in
      'k') up;;
      'j') down;;
      'h') left;;
      'l') right;;
      'i') MODE="INSERT";;
      ':') command_enter;;
    esac
  elif [[ $MODE = 'INSERT' ]];then
    case "$LAST_KEY" in
      $'\e') MODE='NORMAL';;
      $'\b') DIRTY=1;bs;;
      $'\177') DIRTY=1;bs;; # bs sends delete on my terminal
      $'\n') DIRTY=1;nl;;
      [[:print:][:space:]]) DIRTY=1;append "$LAST_KEY";;
    esac
  else
    case "$LAST_KEY" in
      $'\e') command_exit;;
      $'\n') command_eval;;
      $'\177') bs;; # bs is delete on my terminal
      $'\t') autocomplete "$BUFCOM";;
      [[:print:][:space:]]) BUFPATTERN='';append "$LAST_KEY";;
    esac
  fi
}
function cursor_save {
  BUFCSR+=("$LINE_CURSOR;$COLUMN_CURSOR")
}
function cursor_restore {
  echo -ne "\e[${BUFCSR[-1]}H"
  LINE_CURSOR="${BUFCSR[-1]%;*}"
  COLUMN_CURSOR="${BUFCSR[-1]#*;}"
  unset 'BUFCSR[-1]'
}
function up {
  if (( LINE > 1 ));then
    (( LINE-- ))
    (( BUFIDX-- ))
    (( LINE_CURSOR-- ))
    declare -gn BUFCUR=BUFFER[$BUFIDX]
    (( $COLUMN > ${#BUFCUR} )) && COLUMN=${#BUFCUR}+1
    (( COLUMN < COLUMNS )) && COLUMN_CURSOR=COLUMN
  fi
}
function down {
  if (( LINE < ${#BUFFER[@]} ));then
    (( LINE++))
    (( BUFIDX++ ))
    (( LINE_CURSOR++ ))
    declare -gn BUFCUR=BUFFER[$BUFIDX]
    (( COLUMN > ${#BUFCUR} )) && COLUMN=${#BUFCUR}+1
    (( COLUMN < COLUMNS )) && COLUMN_CURSOR=COLUMN
  fi
}
function left {
  (( COLUMN > 1 )) && (( COLUMN-- )) && (( COLUMN_CURSOR-- ))
}
function right {
  (( COLUMN <= ${#BUFCUR} )) && (( COLUMN++ )) && (( COLUMN_CURSOR++ ))
}
function nl {
  local yanked_text="${BUFCUR:$COLUMN-1}"
  declare -g ${!BUFCUR}="${BUFCUR:0:$COLUMN-1}"
  local -i i=${#BUFFER[@]} j=i+1
  while (( i > BUFIDX ));do
    BUFFER[$i]="${BUFFER[$i-1]}"
    (( i-- ))
    (( j-- ))
  done
  COLUMN=1
  BUFIDX=$LINE
  declare -gn BUFCUR=BUFFER[$BUFIDX]
  declare -g ${!BUFCUR}="$yanked_text"
  (( LINE++ ))
}
function bs {
  if (( COLUMN > 1 ));then
    (( COLUMN-- ))
    declare -g ${!BUFCUR}="${BUFCUR:0:$COLUMN-1}${BUFCUR:$COLUMN}"
  fi
}
function append {
  declare -g ${!BUFCUR}="${BUFCUR:0:$COLUMN-1}$1${BUFCUR:$COLUMN-1}"
  (( COLUMN++ ))
  (( COLUMN_CURSOR++ ))
}
function replace {
  declare -g ${!BUFCUR}="$1"
  (( COLUMN=${#BUFCUR}+1 ))
}
function command_enter {
  cursor_save
  LINE_CURSOR=$LINE_COMMAND
  COLUMN_CURSOR=1
  MODE='COMMAND'
  BUFCOM=''
  declare -gn BUFCUR=BUFCOM
  clear_line
}
function clear_line {
  echo -ne "\e[$LINE_CURSOR;1H\e[K"
}
function command_exit {
  cursor_restore
  MODE='NORMAL'
  declare -gn BUFCUR=BUFFER[$BUFIDX]
  BUFMATCH=('')
  IDXMATCH=0
  BUFPATTERN=""
}
function command_eval {
  clear_line
  eval "$BUFCOM"
  BUFCOM=""
  command_exit
}
function s {
  local filename="$FILENAME"
  [[ -n "$1" ]] && filename="$1"
  local filename_abs=$(readlink -f "$filename")
  if [[ -z "$filename" ]];then
    echo -n "No filename provided!"
  elif [[ "$filename_abs" = "$TEDPATH" ]];then
    echo -n "You can't replace me!"
  elif [[ -f "$filename" && "$filename" != "$FILENAME" ]];then
    echo -n "That file already exists"
  else
    echo -n '' > $filename
    local -i i=0 len=${#BUFFER[@]}
    while (( i < len ));do
      echo "${BUFFER[$i]}" >> $filename
      (( i++ ))
    done
    printf "\e[KWrote %d lines to %s" ${#BUFFER[@]} "$filename"
    DIRTY=''
    [[ -z "$FILENAME" ]] && FILENAME="$filename"
  fi
}
function o {
  if [[ -z $1 ]];then
    echo -ne "I need a filename to open"
  elif [[ ! -f $1 ]];then
    echo -ne "That file doesn't exist"
  elif [[ ! -r $1 ]];then
    echo -ne "I don't have permission to read that file"
  else
    save_dirty "Save before opening?"
    local line i=0
    declare -ga BUFFER=('')
    while IFS= read -rs line;do
      BUFFER[$i]="$line"
      (( i++ ))
    done < "$1"
    FILENAME="$1"
    LINE=1
    COLUMN=1
  fi
}
function autocomplete {
  local words=( $1 )
  (( "${#words[@]}" < 2 )) && return # I only autocomplete args
  if [[ -z "$BUFPATTERN" ]];then
    BUFPATTERN="${words[-1]}"
    BUFMATCH=( $(compgen -f "$BUFPATTERN") )
    IDXMATCH=0
  fi
  if (( "${#BUFMATCH[@]}" > 0 ));then
    replace "${1% *} ${BUFMATCH[$IDXMATCH]}"
    (( IDXMATCH++ ))
    (( IDXMATCH == ${#BUFMATCH[@]} )) && IDXMATCH=0
  fi
}
function render {
  echo -ne '\e[?25l'
  if (( LINE_CURSOR < 1 ));then
    LINE_OFFSET=$LINE_OFFSET+$LINE_CURSOR-1
    LINE_CURSOR=1
  elif (( LINE_CURSOR > $WINDOW_LINES ));then
    LINE_OFFSET=$LINE_OFFSET+$LINE_CURSOR-$WINDOW_LINES
    LINE_CURSOR=$WINDOW_LINES
  fi
  if (( COLUMN_CURSOR < 1 ));then
    COLUMN_OFFSET=$COLUMN_OFFSET+$COLUMN_CURSOR-1
    COLUMN_CURSOR=1
  elif (( COLUMN_CURSOR > COLUMNS ));then
    COLUMN_OFFSET=$(( COLUMN_OFFSET+COLUMN_CURSOR-COLUMNS ))
    COLUMN_CURSOR=$COLUMNS
  fi
  cursor_save
  local -i i=$LINE_OFFSET j=1 h=$LINE_OFFSET+$WINDOW_LINES
  while (( i < h ));do
    echo -ne "\e[$j;1H\e[K"
    echo -n "${BUFFER[$i]:$COLUMN_OFFSET:$COLUMNS}"
    (( i++ ))
    (( j++ ))
  done
  [[ -n "$BUFCOM" ]] && echo -ne "\e[$LINE_COMMAND;1H\e[K$BUFCOM"
  local filename="$FILENAME"
  [[ -z "$FILENAME" ]] && filename="No filename"
  echo -ne "\e[$LINE_STATUS;1H\e[K$MODE\t$LINE,$COLUMN\t${#BUFFER[@]} LINES\t$filename\t$LINE_OFFSET\t$LINE_CURSOR"
  cursor_restore
  echo -ne '\e[?25h'
}
function save_dirty {
  if [[ -n "$DIRTY" && -n "$FILENAME" ]];then
    local -u c
    read -N1 -p "$1 " c
    if [[ "$c" = 'Y' ]];then
      BUFCOM=''
      s
    fi
  fi
}
function q {
  save_dirty "Save before exiting?"
  echo -ne '\e[2J\e[H'
  exit
}
function _q {
  command_enter
  q
}
# main
trap _q INT
if [[ -f "$FILENAME" ]];then
  o "$FILENAME"
fi
while :; do render; process_input; done
