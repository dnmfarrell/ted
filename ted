#!/bin/bash
declare TEDPATH=$(readlink -f "$0")
declare SCREEN_SIZE=$(stty size)
declare -i SCREEN_LINES=${SCREEN_SIZE% *}
declare -i SCREEN_COLUMNS=${SCREEN_SIZE#* }
declare -i LINE_STATUS=$SCREEN_LINES
declare -i LINE_COMMAND=$SCREEN_LINES-1
declare -i COLUMN=1
declare -i LINE=1
declare -a BUFCSR=()
declare -i BUFIDX=0
declare -a BUFFER=('')
declare -n BUFCUR=BUFFER[0]
declare LAST_CURSOR=''
declare -x BUFCOM=''
declare LAST_FUN=''
declare LAST_KEY=''
declare MODE='NORMAL'
declare FILENAME="$1"
declare DIRTY=''
declare -ga BUFMATCH=('')
declare -gi IDXMATCH=0
declare -g BUFPATTERN=""

function process_input {
  LAST_FUN=''
  read -srN1 LAST_KEY
  if [[ $MODE = 'NORMAL' ]];then
    case $LAST_KEY in
      'k') up;;
      'j') down;;
      'h') left;;
      'l') right;;
      'i') MODE="INSERT";;
      ':') command_enter;;
    esac
  elif [[ $MODE = 'INSERT' ]];then
    case "$LAST_KEY" in
      $'\e') MODE='NORMAL';;
      $'\b') DIRTY=1;bs;;
      $'\177') DIRTY=1;bs;; # bs sends delete on my terminal
      $'\n') DIRTY=1;nl;;
      [[:print:][:space:]]) DIRTY=1;append "$LAST_KEY";;
    esac
  else
    case "$LAST_KEY" in
      $'\e') command_exit;;
      $'\n') command_eval;;
      $'\177') bs;; # bs is delete on my terminal
      $'\t') autocomplete "$BUFCOM";;
      [[:print:][:space:]]) BUFPATTERN='';append "$LAST_KEY";;
    esac
  fi
}
function cursor_save {
  BUFCSR+=("$LINE;$COLUMN")
}
function cursor_restore {
  echo -ne "\e[${BUFCSR[-1]}H"
  LINE="${BUFCSR[-1]%;*}"
  COLUMN="${BUFCSR[-1]#*;}"
  unset 'BUFCSR[-1]'
}
function up {
  LAST_FUN="up"
  if (( $LINE > 1 ));then
    LINE=$LINE-1
    BUFIDX=$BUFIDX-1
    declare -gn BUFCUR=BUFFER[$BUFIDX]
    (( $COLUMN > ${#BUFCUR} )) && COLUMN=${#BUFCUR}+1
  fi
}
function down {
  LAST_FUN="down"
  if (( $LINE < ${#BUFFER[@]} ));then
    LINE=$LINE+1
    BUFIDX=$BUFIDX+1
    declare -gn BUFCUR=BUFFER[$BUFIDX]
    (( $COLUMN > ${#BUFCUR} )) && COLUMN=${#BUFCUR}+1
  fi
}
function left {
  LAST_FUN="left"
  (( $COLUMN > 1 )) && (( COLUMN-- ))
}
function right {
  LAST_FUN="right"
  (( $COLUMN <= ${#BUFCUR} )) && (( COLUMN++ ))
}
function nl {
  LAST_FUN="nl"
  local yanked_text="${BUFCUR:$COLUMN-1}"
  declare -g ${!BUFCUR}="${BUFCUR:0:$COLUMN-1}"
  local -i i=${#BUFFER[@]} j=i+1
  while (( $i > $BUFIDX ));do
    BUFFER[$i]="${BUFFER[$i-1]}"
    (( i-- ))
    (( j-- ))
  done
  COLUMN=1
  BUFIDX=$LINE
  declare -gn BUFCUR=BUFFER[$BUFIDX]
  declare -g ${!BUFCUR}="$yanked_text"
  (( LINE++ ))
}
function bs {
  LAST_FUN="bs"
  if (( COLUMN > 1 ));then
    (( COLUMN-- ))
    declare -g ${!BUFCUR}="${BUFCUR:0:$COLUMN-1}${BUFCUR:$COLUMN}"
  fi
}
function append {
  LAST_FUN="append"
  declare -g ${!BUFCUR}="${BUFCUR:0:$COLUMN-1}$1${BUFCUR:$COLUMN-1}"
  (( COLUMN++ ))
}
function replace {
  LAST_FUN="replace"
  declare -g ${!BUFCUR}="$1"
  (( COLUMN=${#BUFCUR}+1 ))
}
function command_enter {
  cursor_save
  LINE=$LINE_COMMAND
  COLUMN=1
  MODE='COMMAND'
  BUFCOM=''
  declare -gn BUFCUR=BUFCOM
  clear_line
}
function clear_line {
  echo -ne "\e[$LINE;1H\e[K"
}
function command_exit {
  cursor_restore
  MODE='NORMAL'
  declare -gn BUFCUR=BUFFER[$BUFIDX]
  BUFMATCH=('')
  IDXMATCH=0
  BUFPATTERN=""
}
function command_eval {
  clear_line
  eval "$BUFCOM"
  BUFCOM=""
  command_exit
}
function s {
  LAST_FUN="s"
  local filename="$FILENAME"
  [[ -n "$1" ]] && filename="$1"
  local filename_abs=$(readlink -f "$filename")
  if [[ -z "$filename" ]];then
    echo -n "No filename provided!"
  elif [[ "$filename_abs" = "$TEDPATH" ]];then
    echo -n "You can't replace me!"
  elif [[ -f "$filename" && "$filename" != "$FILENAME" ]];then
    echo -n "That file already exists"
  else
    echo -n '' > $filename
    local -i i=0 len=${#BUFFER[@]}
    while (( i < len ));do
      echo "${BUFFER[$i]}" >> $filename
      (( i++ ))
    done
    printf "\e[KWrote %d lines to %s" ${#BUFFER[@]} "$filename"
    DIRTY=''
    [[ -z "$FILENAME" ]] && FILENAME="$filename"
  fi
}
function o {
  LAST_FUN="o"
  if [[ -z $1 ]];then
    echo -ne "I need a filename to open"
  elif [[ ! -f $1 ]];then
    echo -ne "That file doesn't exist"
  elif [[ ! -r $1 ]];then
    echo -ne "I don't have permission to read that file"
  else
    save_dirty "Save before opening?"
    local line i=0
    declare -ga BUFFER=('')
    while IFS= read -rs line;do
      BUFFER[$i]="$line"
      (( i++ ))
    done < "$1"
    FILENAME="$1"
    LINE=1
    COLUMN=1
  fi
}
function autocomplete {
  LAST_FUN="autocomplete"
  local words=( $1 )
  (( "${#words[@]}" < 2 )) && return # I only autocomplete args
  if [[ -z "$BUFPATTERN" ]];then
    BUFPATTERN="${words[-1]}"
    BUFMATCH=( $(compgen -f "$BUFPATTERN") )
    IDXMATCH=0
  fi
  if (( "${#BUFMATCH[@]}" > 0 ));then
    replace "${1% *} ${BUFMATCH[$IDXMATCH]}"
    (( IDXMATCH++ ))
    (( IDXMATCH == ${#BUFMATCH[@]} )) && IDXMATCH=0
  fi
}
function render {
  LAST_FUN="render"
  echo -ne '\e[?25l'
  cursor_save
  local -i i=0 j=i+1
  while (( j < $LINE_COMMAND ));do
    echo -ne "\e[$j;1H\e[K"
    echo -n "${BUFFER[$i]}"
    (( i++ ))
    (( j++ ))
  done
  [[ -n "$BUFCOM" ]] && echo -ne "\e[$LINE_COMMAND;1H\e[K$BUFCOM"
  local filename="$FILENAME"
  [[ -z "$FILENAME" ]] && filename="No filename"
  echo -ne "\e[$LINE_STATUS;1H\e[K$MODE\t$LINE,$COLUMN\t${#BUFFER[@]} LINES\t$filename"
  cursor_restore
  echo -ne '\e[?25h'
}
function save_dirty {
  if [[ -n "$DIRTY" && -n "$FILENAME" ]];then
    local -u c
    read -N1 -p "$1 " c
    if [[ "$c" = 'Y' ]];then
      BUFCOM=''
      s
    fi
  fi
}
function q {
  save_dirty "Save before exiting?"
  echo -ne '\e[2J\e[H'
  exit
}
function _q {
  command_enter
  q
}
# main
trap _q INT
if [[ -f "$FILENAME" ]];then
  o "$FILENAME"
fi
while :; do render; process_input; done
